
=== File: server/input.md ===


=== File: server/database/init.sql ===

-- SQLBook: Code
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    pubkey VARCHAR NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS credits (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users (id) UNIQUE, -- UNIQUE constraint here
    balance BIGINT NOT NULL DEFAULT 0,
    api_key VARCHAR,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS chats (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users (id),
    input_user TEXT NOT NULL,
    response TEXT,
    tokens_used BIGINT NOT NULL DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_user_id ON chats(user_id);

CREATE INDEX idx_users_pubkey ON users(pubkey);
CREATE INDEX idx_credits_user_id ON credits(user_id);
CREATE INDEX idx_chats_user_id_created_at ON chats(user_id, created_at);

INSERT INTO
    users (pubkey)
VALUES (
        'GtJHNhKQnnJZQTHq2Vh49HpR4yKKJmUonVYbLeS1RPs8'
    );

INSERT INTO
    credits (user_id, balance, api_key)
VALUES (
        1,
        100000000000000,
        'WDAO4Z1Z503DWJH7060GIYGR0TWIIPBM'
    );

INSERT INTO
    chats (user_id, input_user, response, tokens_used)
VALUES (
        1,
        'Hello',
        'Hi there!',
        1
    );
=== File: server/Cargo.toml ===

[package]
name = "server"
version = "0.1.0"
edition.workspace = true
license.workspace = true
authors.workspace = true
repository.workspace = true

[dependencies]
axum = { workspace = true }
tokio = { workspace = true }
tracing-subscriber.workspace = true
tracing = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
sqlx = { workspace = true }
dotenvy = { workspace = true }
chrono = { workspace = true }
tower-http = { workspace = true }
http-body-util = { workspace = true }
solana-sdk = { workspace = true }
reqwest.workspace = true
uuid = { version = "1.11.0", features = ["v4"] }
rand = "0.8.5"
sdk = { path = "../sdk", version = "0.0.1" }

[dev-dependencies]
tower = { workspace = true }

=== File: server/output.json ===

[
  {
    "details": {
      "blocktime": 1729179206,
      "meta": {
        "err": null,
        "fee": 10000,
        "innerinstructions": [],
        "logmessages": [
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success"
        ],
        "postbalances": [672598468, 0, 1000836580, 1],
        "posttokenbalances": [],
        "prebalances": [672609468, 0, 1000835580, 1],
        "pretokenbalances": [],
        "rewards": [],
        "slot": null,
        "status": { "ok": null }
      },
      "slot": 296153212,
      "transaction": {
        "message": {
          "accountkeys": [
            "6s3qfeth7kfqupco4df2owu8suhmjz8c9hnka9hrazno",
            "7fjbrjmvca2pyczvirbeqsuf1usvpl4lnzjaap3dj2cx",
            "humzdntbanbpyex53irwaykvxoulmeyn85mvaon81pxe",
            "11111111111111111111111111111111"
          ],
          "header": {
            "numreadonlysignedaccounts": 0,
            "numreadonlyunsignedaccounts": 1,
            "numrequiredsignatures": 2
          },
          "instructions": [
            {
              "accounts": [0, 1],
              "data": "3bxs4fftu9t19dnf",
              "programidindex": 3,
              "stackheight": null
            },
            {
              "accounts": [1, 2],
              "data": "3bxs4fftu9t19dnf",
              "programidindex": 3,
              "stackheight": null
            }
          ],
          "recentblockhash": "7zzqs86cjylyyn58vzydgxdv6sjmkkpvdwcwqp6b5yyl"
        },
        "signatures": [
          "4dsjzbcz6ge2v6uan4xk8ck84exqcth39vaamgeb3cu6xm8b2l9gtqpazqmuex9mb76rchvkumftz371gtk1txtd",
          "4b9kw1kn2zihj69wzjdd6tdxpsllsdw36jpxjgj6b9br4ekvm9kwpys8ii7mvyxrdsum8qytajmkqszqtnhhb5h"
        ]
      }
    },
    "signature": "4dsjzbcz6ge2v6uan4xk8ck84exqcth39vaamgeb3cu6xm8b2l9gtqpazqmuex9mb76rchvkumftz371gtk1txtd",
    "slot": 296153212,
    "status": "success",
    "timestamp": 1729179206
  },
  {
    "details": {
      "blocktime": 1729179125,
      "meta": {
        "err": null,
        "fee": 85000,
        "innerinstructions": [],
        "logmessages": [
          "program computebudget111111111111111111111111111111 invoke [1]",
          "program computebudget111111111111111111111111111111 success",
          "program computebudget111111111111111111111111111111 invoke [1]",
          "program computebudget111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success"
        ],
        "postbalances": [1000835580, 6699999000000, 1, 1],
        "posttokenbalances": [],
        "prebalances": [6699999920580, 1000000000, 1, 1],
        "pretokenbalances": [],
        "rewards": [],
        "slot": null,
        "status": { "ok": null }
      },
      "slot": 296153044,
      "transaction": {
        "message": {
          "accountkeys": [
            "humzdntbanbpyex53irwaykvxoulmeyn85mvaon81pxe",
            "7fs9uqvpvvnbwena2hrfqbbeya8rgpuuzyyzlrypj2cx",
            "11111111111111111111111111111111",
            "computebudget111111111111111111111111111111"
          ],
          "header": {
            "numreadonlysignedaccounts": 0,
            "numreadonlyunsignedaccounts": 2,
            "numrequiredsignatures": 1
          },
          "instructions": [
            {
              "accounts": [],
              "data": "3atjtxcctbsv",
              "programidindex": 3,
              "stackheight": null
            },
            {
              "accounts": [],
              "data": "fj2eoy",
              "programidindex": 3,
              "stackheight": null
            },
            {
              "accounts": [0, 1],
              "data": "3bxs4z5ofsqfirjh",
              "programidindex": 2,
              "stackheight": null
            }
          ],
          "recentblockhash": "hyjapb5gx2bqgawxxfutakjslyaqzagag4tpn1ewzctd"
        },
        "signatures": [
          "3uqawb24yaheouzehfut5g3bqqvw3ijcne46nhqe5y7cpg7zh9bzf29kmzvhdfot5tnd17s9ydkaavmwt4gvrj5s"
        ]
      }
    },
    "signature": "3uqawb24yaheouzehfut5g3bqqvw3ijcne46nhqe5y7cpg7zh9bzf29kmzvhdfot5tnd17s9ydkaavmwt4gvrj5s",
    "slot": 296153044,
    "status": "success",
    "timestamp": 1729179125
  },
  {
    "details": {
      "blocktime": 1729179057,
      "meta": {
        "err": null,
        "fee": 5600,
        "innerinstructions": [],
        "logmessages": [
          "program computebudget111111111111111111111111111111 invoke [1]",
          "program computebudget111111111111111111111111111111 success",
          "program computebudget111111111111111111111111111111 invoke [1]",
          "program computebudget111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success"
        ],
        "postbalances": [
          2262175235, 266985976, 291208027, 4124546279, 98921470, 47263866,
          684210826, 39021680, 201954346729, 75601975, 31062362, 61059820,
          992357797, 2268053039, 710617219, 9874795, 1178525957, 6699999920580,
          208467205, 1, 1
        ],
        "posttokenbalances": [],
        "prebalances": [
          2262182635, 266985876, 291207927, 4124546179, 98921370, 47263766,
          684210726, 39021580, 201954346629, 75601875, 31062262, 61059720,
          992357697, 2268052939, 710617119, 9874695, 1178525857, 6699999920480,
          208467105, 1, 1
        ],
        "pretokenbalances": [],
        "rewards": [],
        "slot": null,
        "status": { "ok": null }
      },
      "slot": 296152896,
      "transaction": {
        "message": {
          "accountkeys": [
            "habp5bncmssbc3vkchyebepym5dctnryeg2lvg464e96",
            "2krz7w2sbxe12s6mnirqicuysmuml6mec7yych2wbqip",
            "57g9cgvywksxypvmu3iefqjxvcdtq45bvpckhvay9rrs",
            "5jk3ym9qzew7uv7kgmaqw72nco8oxhs553zaasrwawhl",
            "64t1sjx3a1yqhdvxjrdhj1magfszjmd7fsgu7hr8zjlz",
            "6aqrcj1as8jkuvyofukhpnztegaesegnbkfhmfvr8kph",
            "6js18rizfyhzet9jcmnfj3s2sg7honnt4d1bey4nzfjo",
            "742a6uladqkhwrfwsxy2uqorwt1wxepy5jcucn75ig6",
            "8loyn38nuzeu2ns3r7t4of4yx6eayjzuxhxztlzgrpmb",
            "8yt4aysz1q9fpbzg4kkvhzt9anbbyjpqjnejog4qkmke",
            "93deefj1pofpxly3bvjtbsc57xmfsmnduhsddpphoiuu",
            "9a6d8ygvvjpjhryjzmvwhyynglxevkt8yy5yxredfupp",
            "bnbbbhvbrpepsieattv4ts2o2xoe4mykjmdyk7uxzdcw",
            "ejpzcjw9gqxvaxeiptsf93fmouvwkttindkt6tb93uqg",
            "fkxep5ws8rg37sr4qdad5hohx1yxizhbi17mcwmjplti",
            "hh1kb1dto4f8jtkkcstsdoh7ivq2cmmcy5nfae4aj6sv",
            "hiuamcd18cwlekkucdukqg9vjfbughkcvsdyzzcypcxu",
            "humzdntbanbpyex53irwaykvxoulmeyn85mvaon81pxe",
            "hyykie831gjzbjunxfwlgpdtmh4nazzwi9h2k45ny6uv",
            "11111111111111111111111111111111",
            "computebudget111111111111111111111111111111"
          ],
          "header": {
            "numreadonlysignedaccounts": 0,
            "numreadonlyunsignedaccounts": 2,
            "numrequiredsignatures": 1
          },
          "instructions": [
            {
              "accounts": [],
              "data": "jnv5sf",
              "programidindex": 20,
              "stackheight": null
            },
            {
              "accounts": [],
              "data": "3qawfka3mjas",
              "programidindex": 20,
              "stackheight": null
            },
            {
              "accounts": [0, 13],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 18],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 6],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 3],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 9],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 5],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 14],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 16],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 11],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 12],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 1],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 17],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 7],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 8],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 10],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 15],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 2],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 4],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            }
          ],
          "recentblockhash": "9acq1tngfcskvdvf6lgkdfkmvvw6nnuyonu4zy6zhlti"
        },
        "signatures": [
          "3mcub44vvbclpcdpaazrcrfwf3ftzqcnrlqtxdhhot1nvmvcekhntn9mcwbp7lte8inblrqkniplkqzqguhmhkzn"
        ]
      }
    },
    "signature": "3mcub44vvbclpcdpaazrcrfwf3ftzqcnrlqtxdhhot1nvmvcekhntn9mcwbp7lte8inblrqkniplkqzqguhmhkzn",
    "slot": 296152896,
    "status": "success",
    "timestamp": 1729179057
  },
  {
    "details": {
      "blocktime": 1729179057,
      "meta": {
        "err": null,
        "fee": 5600,
        "innerinstructions": [],
        "logmessages": [
          "program computebudget111111111111111111111111111111 invoke [1]",
          "program computebudget111111111111111111111111111111 success",
          "program computebudget111111111111111111111111111111 invoke [1]",
          "program computebudget111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success"
        ],
        "postbalances": [
          2886027587, 266985876, 291207827, 4124546179, 98921270, 47263766,
          684210726, 39021580, 201954346629, 75601875, 31062262, 61059720,
          992357697, 2268052939, 710617119, 9874695, 1178525857, 6699999920480,
          208467105, 1, 1
        ],
        "posttokenbalances": [],
        "prebalances": [
          2886034987, 266985776, 291207727, 4124546079, 98921170, 47263666,
          684210626, 39021480, 201954346529, 75601775, 31062162, 61059620,
          992357597, 2268052839, 710617019, 9874595, 1178525757, 6699999920380,
          208467005, 1, 1
        ],
        "pretokenbalances": [],
        "rewards": [],
        "slot": null,
        "status": { "ok": null }
      },
      "slot": 296152895,
      "transaction": {
        "message": {
          "accountkeys": [
            "flipgg2ytvmgfhipkkriahkdmmxgp6cdefx9uf5o7zc",
            "2krz7w2sbxe12s6mnirqicuysmuml6mec7yych2wbqip",
            "57g9cgvywksxypvmu3iefqjxvcdtq45bvpckhvay9rrs",
            "5jk3ym9qzew7uv7kgmaqw72nco8oxhs553zaasrwawhl",
            "64t1sjx3a1yqhdvxjrdhj1magfszjmd7fsgu7hr8zjlz",
            "6aqrcj1as8jkuvyofukhpnztegaesegnbkfhmfvr8kph",
            "6js18rizfyhzet9jcmnfj3s2sg7honnt4d1bey4nzfjo",
            "742a6uladqkhwrfwsxy2uqorwt1wxepy5jcucn75ig6",
            "8loyn38nuzeu2ns3r7t4of4yx6eayjzuxhxztlzgrpmb",
            "8yt4aysz1q9fpbzg4kkvhzt9anbbyjpqjnejog4qkmke",
            "93deefj1pofpxly3bvjtbsc57xmfsmnduhsddpphoiuu",
            "9a6d8ygvvjpjhryjzmvwhyynglxevkt8yy5yxredfupp",
            "bnbbbhvbrpepsieattv4ts2o2xoe4mykjmdyk7uxzdcw",
            "ejpzcjw9gqxvaxeiptsf93fmouvwkttindkt6tb93uqg",
            "fkxep5ws8rg37sr4qdad5hohx1yxizhbi17mcwmjplti",
            "hh1kb1dto4f8jtkkcstsdoh7ivq2cmmcy5nfae4aj6sv",
            "hiuamcd18cwlekkucdukqg9vjfbughkcvsdyzzcypcxu",
            "humzdntbanbpyex53irwaykvxoulmeyn85mvaon81pxe",
            "hyykie831gjzbjunxfwlgpdtmh4nazzwi9h2k45ny6uv",
            "11111111111111111111111111111111",
            "computebudget111111111111111111111111111111"
          ],
          "header": {
            "numreadonlysignedaccounts": 0,
            "numreadonlyunsignedaccounts": 2,
            "numrequiredsignatures": 1
          },
          "instructions": [
            {
              "accounts": [],
              "data": "jnv5sf",
              "programidindex": 20,
              "stackheight": null
            },
            {
              "accounts": [],
              "data": "3qawfka3mjas",
              "programidindex": 20,
              "stackheight": null
            },
            {
              "accounts": [0, 13],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 18],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 6],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 3],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 9],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 5],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 14],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 16],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 11],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 12],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 1],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 17],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 7],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 8],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 10],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 15],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 2],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            },
            {
              "accounts": [0, 4],
              "data": "3bxs4hanwshuzcbh",
              "programidindex": 19,
              "stackheight": null
            }
          ],
          "recentblockhash": "9acq1tngfcskvdvf6lgkdfkmvvw6nnuyonu4zy6zhlti"
        },
        "signatures": [
          "2vcjhahyhzdwhiwsyzhwjkae35fapcngzchbp41fbngnwfgfgjcuczsea3ufyu7ckha8fmtdzhxrj1k11w8mjtgm"
        ]
      }
    },
    "signature": "2vcjhahyhzdwhiwsyzhwjkae35fapcngzchbp41fbngnwfgfgjcuczsea3ufyu7ckha8fmtdzhxrj1k11w8mjtgm",
    "slot": 296152895,
    "status": "success",
    "timestamp": 1729179057
  },
  {
    "details": {
      "blocktime": 1729179046,
      "meta": {
        "err": null,
        "fee": 85000,
        "innerinstructions": [],
        "logmessages": [
          "program computebudget111111111111111111111111111111 invoke [1]",
          "program computebudget111111111111111111111111111111 success",
          "program computebudget111111111111111111111111111111 invoke [1]",
          "program computebudget111111111111111111111111111111 success",
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success"
        ],
        "postbalances": [6699999920380, 1000000000, 1, 1],
        "posttokenbalances": [],
        "prebalances": [6701000005380, 0, 1, 1],
        "pretokenbalances": [],
        "rewards": [],
        "slot": null,
        "status": { "ok": null }
      },
      "slot": 296152872,
      "transaction": {
        "message": {
          "accountkeys": [
            "humzdntbanbpyex53irwaykvxoulmeyn85mvaon81pxe",
            "7fs9uqvpvvnbwena2hrfqbbeya8rgpuuzyyzlrypj2cx",
            "11111111111111111111111111111111",
            "computebudget111111111111111111111111111111"
          ],
          "header": {
            "numreadonlysignedaccounts": 0,
            "numreadonlyunsignedaccounts": 2,
            "numrequiredsignatures": 1
          },
          "instructions": [
            {
              "accounts": [],
              "data": "3atjtxcctbsv",
              "programidindex": 3,
              "stackheight": null
            },
            {
              "accounts": [],
              "data": "fj2eoy",
              "programidindex": 3,
              "stackheight": null
            },
            {
              "accounts": [0, 1],
              "data": "3bxs3zzlzlulqeyx",
              "programidindex": 2,
              "stackheight": null
            }
          ],
          "recentblockhash": "44hnb98e6jtnz9jaf5j2edekxdxadcqkxiejwlfwkgki"
        },
        "signatures": [
          "ssnegcovxfek1te3wj8fqgn5ub75brji2fme1mc9yqopos9vplhot5rrbp3jpir3figd3ydw3c6vyyy9hqjmskg"
        ]
      }
    },
    "signature": "ssnegcovxfek1te3wj8fqgn5ub75brji2fme1mc9yqopos9vplhot5rrbp3jpir3figd3ydw3c6vyyy9hqjmskg",
    "slot": 296152872,
    "status": "success",
    "timestamp": 1729179046
  },
  {
    "details": {
      "blocktime": 1729178693,
      "meta": {
        "err": null,
        "fee": 5000,
        "innerinstructions": [],
        "logmessages": [
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success"
        ],
        "postbalances": [19690997447357, 6701000005380, 1],
        "posttokenbalances": [],
        "prebalances": [20683997452357, 5708000005380, 1],
        "pretokenbalances": [],
        "rewards": [],
        "slot": null,
        "status": { "ok": null }
      },
      "slot": 296152116,
      "transaction": {
        "message": {
          "accountkeys": [
            "grzspengu2kxom9mw8esodmqou52adhmnwmzpp2nusgh",
            "humzdntbanbpyex53irwaykvxoulmeyn85mvaon81pxe",
            "11111111111111111111111111111111"
          ],
          "header": {
            "numreadonlysignedaccounts": 0,
            "numreadonlyunsignedaccounts": 1,
            "numrequiredsignatures": 1
          },
          "instructions": [
            {
              "accounts": [0, 1],
              "data": "3bxs3zwuubafwypb",
              "programidindex": 2,
              "stackheight": null
            }
          ],
          "recentblockhash": "gzoijcgdacwrsskn2pre4vrawh8dyurhhldmymz96d1f"
        },
        "signatures": [
          "2kdfdwhwtnqgxcm4edbjs4rd2zvzfvmvhi2vdfrru9yizdqxnx3j6frywmwqr4dcsqzqxtfmpispawp9pmeudhmn"
        ]
      }
    },
    "signature": "2kdfdwhwtnqgxcm4edbjs4rd2zvzfvmvhi2vdfrru9yizdqxnx3j6frywmwqr4dcsqzqxtfmpispawp9pmeudhmn",
    "slot": 296152116,
    "status": "success",
    "timestamp": 1729178693
  },
  {
    "details": {
      "blocktime": 1729178678,
      "meta": {
        "err": null,
        "fee": 5000,
        "innerinstructions": [],
        "logmessages": [
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success"
        ],
        "postbalances": [20683997452357, 5708000005380, 1],
        "posttokenbalances": [],
        "prebalances": [25196997457357, 1195000005380, 1],
        "pretokenbalances": [],
        "rewards": [],
        "slot": null,
        "status": { "ok": null }
      },
      "slot": 296152084,
      "transaction": {
        "message": {
          "accountkeys": [
            "grzspengu2kxom9mw8esodmqou52adhmnwmzpp2nusgh",
            "humzdntbanbpyex53irwaykvxoulmeyn85mvaon81pxe",
            "11111111111111111111111111111111"
          ],
          "header": {
            "numreadonlysignedaccounts": 0,
            "numreadonlyunsignedaccounts": 1,
            "numrequiredsignatures": 1
          },
          "instructions": [
            {
              "accounts": [0, 1],
              "data": "3bxs3zs4umkwpmq3",
              "programidindex": 2,
              "stackheight": null
            }
          ],
          "recentblockhash": "hfczb8uysfqdhkqjhwfkojpfqsazikb4jnq7tojrhgk7"
        },
        "signatures": [
          "3m3hnuyurxgqlikaj4niqv6psuqlmh7staujfs9yuoddxisssufygm2vvdbb4tctlcj5t125nt6htkgmy7asymth"
        ]
      }
    },
    "signature": "3m3hnuyurxgqlikaj4niqv6psuqlmh7staujfs9yuoddxisssufygm2vvdbb4tctlcj5t125nt6htkgmy7asymth",
    "slot": 296152084,
    "status": "success",
    "timestamp": 1729178678
  },
  {
    "details": {
      "blocktime": 1729178662,
      "meta": {
        "err": null,
        "fee": 5000,
        "innerinstructions": [],
        "logmessages": [
          "program 11111111111111111111111111111111 invoke [1]",
          "program 11111111111111111111111111111111 success"
        ],
        "postbalances": [25196997457357, 1195000005380, 1],
        "posttokenbalances": [],
        "prebalances": [26390997462357, 1000005380, 1],
        "pretokenbalances": [],
        "rewards": [],
        "slot": null,
        "status": { "ok": null }
      },
      "slot": 296152049,
      "transaction": {
        "message": {
          "accountkeys": [
            "grzspengu2kxom9mw8esodmqou52adhmnwmzpp2nusgh",
            "humzdntbanbpyex53irwaykvxoulmeyn85mvaon81pxe",
            "11111111111111111111111111111111"
          ],
          "header": {
            "numreadonlysignedaccounts": 0,
            "numreadonlyunsignedaccounts": 1,
            "numrequiredsignatures": 1
          },
          "instructions": [
            {
              "accounts": [0, 1],
              "data": "3bxs3zt4tnc5q9uz",
              "programidindex": 2,
              "stackheight": null
            }
          ],
          "recentblockhash": "eykgejh1tsgn2iercbidsiaf9wnuaypbsijql6c5kpyh"
        },
        "signatures": [
          "3d4ycvisryyobiewykid4v52i6xqcbqpbgqa8fn7gukbcjhqyyffmnyfmcvzocb5hcmkvy5fbtg51dz7tgvw4l3q"
        ]
      }
    },
    "signature": "3d4ycvisryyobiewykid4v52i6xqcbqpbgqa8fn7gukbcjhqyyffmnyfmcvzocb5hcmkvy5fbtg51dz7tgvw4l3q",
    "slot": 296152049,
    "status": "success",
    "timestamp": 1729178662
  }
]

=== File: server/test.sh ===

#!/bin/bash

BASE_URL="http://localhost:5500"
API_KEY="WDAO4Z1Z503DWJH7060GIYGR0TWIIPBM"

check_response() {
  local response="$1"
  local status="$2"
  local expected="$3"
  
  echo "Response: $response"
  
  if [[ "$status" -eq "$expected" ]]; then
    echo "‚úÖ Test passed"
  else
    echo "‚ùå Test failed (Expected: $expected, Got: $status)"
    exit 1
  fi
}

# Test health endpoint
echo "Testing /health..."
response=$(curl -s -o /dev/null -w "%{http_code}" -X GET "$BASE_URL/health")
check_response "" "$response" 200

# Test create user
echo "Creating user..."
response=$(curl -s -w "\n%{http_code}" -H "Content-Type: application/json" -X POST -d '{
  "pubkey": "GtJHNhKQnnJZQTHq2Vh49HpR4yKKJmUonVYbLeS1RPs8"
}' "$BASE_URL/users")
status=$(echo "$response" | tail -n1)
check_response "$response" "$status" 200

# Test get users
echo "Fetching users..."
response=$(curl -s -w "\n%{http_code}" -X GET "$BASE_URL/users")
status=$(echo "$response" | tail -n1)
check_response "$response" "$status" 200

# Test buy credits
echo "Buying credits..."
response=$(curl -s -w "\n%{http_code}" -H "Content-Type: application/json" -H "x-api-key: $API_KEY" -X POST -d '{
  "user_pubkey": "GtJHNhKQnnJZQTHq2Vh49HpR4yKKJmUonVYbLeS1RPs8",
  "amount": 5000
}' "$BASE_URL/credits/buy")
status=$(echo "$response" | tail -n1)
check_response "$response" "$status" 201

# Test chatbot interaction
echo "Chatbot interaction..."
response=$(curl -s -w "\n%{http_code}" -H "Content-Type: application/json" -H "x-api-key: $API_KEY" -X POST -d '{
  "input_user": "Hello, how are you?",
  "address": "GtJHNhKQnnJZQTHq2Vh49HpR4yKKJmUonVYbLeS1RPs8"
}' "$BASE_URL/chatbot/interact")
status=$(echo "$response" | tail -n1)
check_response "$response" "$status" 200

echo "All tests passed üéâ"
=== File: server/src/models/user.rs ===

#[derive(sqlx::FromRow)]
pub struct UserModel {
    pub id: i32,
    pub pubkey: String,
}

=== File: server/src/models/credits.rs ===

#[derive(sqlx::FromRow)]
#[allow(dead_code)]
pub struct CreditModel {
    pub id: i32,
    pub user_id: i32,
    pub balance: i64,
    pub created_at: chrono::NaiveDateTime,
}

=== File: server/src/models/mod.rs ===

pub mod chat;
pub mod credits;
pub mod user;

pub use {chat::*, credits::*, user::*};

=== File: server/src/models/chat.rs ===

use chrono::NaiveDateTime;

#[derive(sqlx::FromRow)]
pub struct ChatModel {
    pub id: i32,
    pub user_id: i32,
    pub input_user: String,
    pub response: Option<String>,
    pub tokens_used: i64,
    pub created_at: NaiveDateTime,
}

=== File: server/src/db.rs ===

use {
    sqlx::{postgres::PgPoolOptions, Pool, Postgres},
    std::env,
};

pub type DbPool = Pool<Postgres>;

pub async fn connect() -> DbPool {
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await
        .expect("Failed to connect to the database")
}

=== File: server/src/main.rs ===

mod db;
mod models;
mod routes;

use {
    axum::{
        routing::{get, post},
        Router,
    },
    db::connect,
    dotenvy::dotenv,
    routes::{
        agent::{generate_query, generate_report},
        chatbot::{chatbot_interact, get_chat_by_id, get_chats_for_user},
        credits::{buy_credits, refund_credits},
        users::{create_user, get_users},
    },
};

pub const AGENT_API_URL: &str = "http://localhost:8000";

#[tokio::main]
async fn main() {
    dotenv().ok();
    tracing_subscriber::fmt::init();

    let pool = connect().await;

    let agent_router = Router::new()
        .route("/generate-query", post(generate_query))
        .route("/generate-report", post(generate_report));
    let chatbot_router = Router::new()
        .route("/interact", post(chatbot_interact))
        .route("/chats", get(get_chats_for_user))
        .route("/chats/:id", get(get_chat_by_id));

    let app = Router::new()
        .route("/health", get(|| async { "ok" }))
        .route("/users", get(get_users).post(create_user))
        .route("/credits/buy", post(buy_credits))
        .route("/credits/refund", post(refund_credits))
        .nest("/agent", agent_router)
        .nest("/chatbot", chatbot_router)
        .with_state(pool);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:5500").await.unwrap();

    println!("Listening on: http://{}", listener.local_addr().unwrap());
    axum::serve(listener, app).await.unwrap();
}

=== File: server/src/routes/users.rs ===

use {
    crate::models::UserModel,
    axum::{extract::State, http::StatusCode, Json},
    serde::{Deserialize, Serialize},
    sqlx::PgPool,
};

#[derive(Deserialize)]
pub struct CreateUser {
    pub pubkey: String,
}

#[derive(Serialize)]
pub struct User {
    pub id: i32,
    pub pubkey: String,
}

pub async fn create_user(
    State(pool): State<PgPool>,
    Json(payload): Json<CreateUser>,
) -> Result<(StatusCode, Json<User>), (StatusCode, String)> {
    // Ensure pubkey respects Solana public key length
    // if payload.pubkey.len() != 44 {
    //     return Err((StatusCode::BAD_REQUEST, "Invalid pubkey length".into()));
    // }

    // Check if user already exists
    if let Some(existing_user) =
        sqlx::query_as::<_, UserModel>("SELECT id, pubkey FROM users WHERE pubkey = $1")
            .bind(&payload.pubkey)
            .fetch_optional(&pool)
            .await
            .expect("Failed to query user")
    {
        return Ok((
            StatusCode::OK,
            Json(User {
                id: existing_user.id,
                pubkey: existing_user.pubkey,
            }),
        ));
    }

    // Insert new user
    let user = sqlx::query_as::<_, UserModel>(
        "INSERT INTO users (pubkey) VALUES ($1) RETURNING id, pubkey",
    )
    .bind(&payload.pubkey)
    .fetch_one(&pool)
    .await
    .map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Failed to insert user: {}", e),
        )
    })?;

    Ok((
        StatusCode::CREATED,
        Json(User {
            id: user.id,
            pubkey: user.pubkey,
        }),
    ))
}

pub async fn get_users(State(pool): State<PgPool>) -> Json<Vec<User>> {
    let users = sqlx::query_as::<_, UserModel>("SELECT id, pubkey FROM users")
        .fetch_all(&pool)
        .await
        .expect("Failed to fetch users")
        .into_iter()
        .map(|user| User {
            id: user.id,
            pubkey: user.pubkey,
        })
        .collect();

    Json(users)
}

=== File: server/src/routes/credits.rs ===

use {
    crate::models::{CreditModel, UserModel},
    axum::{extract::State, http::StatusCode, Json},
    serde::{Deserialize, Serialize},
    sqlx::PgPool,
};

#[derive(Deserialize)]
pub struct BuyCredits {
    pub user_pubkey: String,
    pub amount: i64, // Amount in credits
}

#[derive(Serialize)]
pub struct CreditResponse {
    pub user_pubkey: String,
    pub new_balance: i64,
    pub api_key: Option<String>,
}
#[derive(Serialize)]
pub struct ValidateCreditsResponse {
    pub success: bool,
    pub remaining_balance: i64,
}

// Add function to generate API key
fn generate_api_key() -> String {
    use rand::{thread_rng, Rng};
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let mut rng = thread_rng();
    let key: String = (0..32)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect();
    key
}

// Modify buy_credits to handle API key
pub async fn buy_credits(
    State(pool): State<PgPool>,
    Json(payload): Json<BuyCredits>,
) -> Result<(StatusCode, Json<CreditResponse>), (StatusCode, String)> {
    let user = sqlx::query_as::<_, UserModel>("SELECT id, pubkey FROM users WHERE pubkey = $1")
        .bind(&payload.user_pubkey)
        .fetch_optional(&pool)
        .await
        .map_err(|e| {
            eprintln!("Database error: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Database error".to_string(),
            )
        })?;

    match user {
        Some(user) => {
            let api_key = generate_api_key();
            match update_or_insert_credits(&pool, user.id, payload.amount, &api_key).await {
                Ok(credit) => Ok((
                    StatusCode::CREATED,
                    Json(CreditResponse {
                        user_pubkey: payload.user_pubkey,
                        new_balance: credit.balance,
                        api_key: Some(api_key),
                    }),
                )),
                Err(e) => Err(e),
            }
        }
        None => Ok((
            StatusCode::NOT_FOUND,
            Json(CreditResponse {
                user_pubkey: payload.user_pubkey,
                new_balance: 0,
                api_key: None,
            }),
        )),
    }
}

async fn update_or_insert_credits(
    pool: &PgPool,
    user_id: i32,
    amount: i64,
    api_key: &str,
) -> Result<CreditModel, (StatusCode, String)> {
    let current_balance = sqlx::query_scalar::<_, i64>(
        "SELECT balance FROM credits WHERE user_id = $1 FOR UPDATE",
    )
    .bind(user_id)
    .fetch_one(pool)
    .await
    .map_err(|e| {
        eprintln!("Credits operation error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            "Failed to fetch credits".to_string(),
        )
    })?;

    let new_amount = current_balance + amount;

    let credit = sqlx::query_as::<_, CreditModel>(
        "INSERT INTO credits (user_id, balance, api_key) 
         VALUES ($1, $2, $3)
         ON CONFLICT (user_id) 
         DO UPDATE SET balance = EXCLUDED.balance,
                     api_key = COALESCE(credits.api_key, EXCLUDED.api_key)
         RETURNING *",
    )
    .bind(user_id)
    .bind(new_amount)
    .bind(api_key)
    .fetch_one(pool)
    .await
    .map_err(|e| {
        eprintln!("Credits operation error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            "Failed to update credits".to_string(),
        )
    })?;

    Ok(credit)
}

#[derive(Deserialize)]
pub struct RefundCredits {
    pub user_pubkey: String,
    pub amount: i64, // Amount to refund in credits
}

pub async fn refund_credits(
    State(pool): State<PgPool>,
    Json(payload): Json<RefundCredits>,
) -> Result<(StatusCode, Json<CreditResponse>), (StatusCode, String)> {
    let user = sqlx::query_as::<_, UserModel>("SELECT id, pubkey FROM users WHERE pubkey = $1")
        .bind(&payload.user_pubkey)
        .fetch_optional(&pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    let mut balance = 0;

    if let Some(user) = user {
        match update_credit_balance(&pool, user.id as i64, payload.amount).await {
            Ok(new_balance) => balance = new_balance,
            Err(e) => return Err(e),
        }
    }

    let response = CreditResponse {
        user_pubkey: payload.user_pubkey,
        new_balance: balance,
        api_key: None,
    };

    Ok((StatusCode::CREATED, Json(response)))
}

async fn update_credit_balance(
    pool: &PgPool,
    user_id: i64,
    amount: i64,
) -> Result<i64, (StatusCode, String)> {
    let credit =
        sqlx::query_as::<_, CreditModel>("SELECT * FROM credits WHERE user_id = $1 FOR UPDATE")
            .bind(user_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    if let Some(credit) = credit {
        if credit.balance < amount {
            return Err((StatusCode::BAD_REQUEST, "Insufficient balance".to_string()));
        }

        let credit = sqlx::query_as::<_, CreditModel>(
            "UPDATE credits SET balance = balance - $1 WHERE user_id = $2 RETURNING *",
        )
        .bind(amount)
        .bind(user_id)
        .fetch_one(pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

        return Ok(credit.balance);
    }

    Ok(0)
}

=== File: server/src/routes/mod.rs ===

pub mod agent;
pub mod chatbot;
pub mod credits;
pub mod users;

=== File: server/src/routes/chatbot.rs ===

use {
    super::agent::{generate_report, generate_report_service, QueryRequestReport}, crate::{
        models::ChatModel,
        routes::agent::fetch_credit_info, // Remove unused imports
    }, axum::{
        extract::{Path, State},
        http::{HeaderMap, StatusCode},
        Json,
    }, chrono::NaiveDateTime, serde::{Deserialize, Serialize, Serializer}, sqlx::PgPool, swquery::{client::Network, SWqueryClient}
};

fn serialize_naive_date_time<S>(date: &NaiveDateTime, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    let s = date.format("%Y-%m-%d %H:%M:%S").to_string();
    serializer.serialize_str(&s)
}

#[derive(Serialize)]
pub struct GetChatsResponse {
    pub id: i32,
    pub user_id: i32,
    pub input_user: String,
    pub response: Option<String>,
    pub tokens_used: i64,
    #[serde(serialize_with = "serialize_naive_date_time")]
    pub created_at: NaiveDateTime,
}

/// Retrieve all chats for a specific user
pub async fn get_chats_for_user(
    State(pool): State<PgPool>,
    user_pubkey: String,
) -> Result<(StatusCode, Json<Vec<GetChatsResponse>>), (StatusCode, String)> {
    let chats = sqlx::query_as::<_, ChatModel>(
        "SELECT c.* 
         FROM chats c
         JOIN users u ON u.id = c.user_id
         WHERE u.pubkey = $1
         ORDER BY c.created_at DESC",
    )
    .bind(user_pubkey)
    .fetch_all(&pool)
    .await
    .map_err(|e| {
        eprintln!("Database error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            "Database error".to_string(),
        )
    })?;

    let response: Vec<GetChatsResponse> = chats
        .into_iter()
        .map(|chat| GetChatsResponse {
            id: chat.id,
            user_id: chat.user_id,
            input_user: chat.input_user,
            response: chat.response,
            tokens_used: chat.tokens_used,
            created_at: chat.created_at,
        })
        .collect();

    Ok((StatusCode::OK, Json(response)))
}

#[derive(Serialize)]
pub struct ChatDetailsResponse {
    pub id: i32,
    pub input_user: String,
    pub response: Option<String>,
    pub tokens_used: i64,
    pub created_at: NaiveDateTime,
}

/// Retrieve details of a specific chat
pub async fn get_chat_by_id(
    State(pool): State<PgPool>,
    Path(chat_id): Path<i32>, // Extracts the chat ID from the path
) -> Result<(StatusCode, Json<ChatDetailsResponse>), (StatusCode, String)> {
    let chat = sqlx::query_as::<_, ChatModel>(
        "SELECT id, input_user, response, tokens_used, created_at 
         FROM chats 
         WHERE id = $1",
    )
    .bind(chat_id)
    .fetch_optional(&pool)
    .await
    .map_err(|e| {
        eprintln!("Database error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            "Database error".to_string(),
        )
    })?;

    if let Some(chat) = chat {
        Ok((
            StatusCode::OK,
            Json(ChatDetailsResponse {
                id: chat.id,
                input_user: chat.input_user,
                response: chat.response,
                tokens_used: chat.tokens_used,
                created_at: chat.created_at,
            }),
        ))
    } else {
        Err((StatusCode::NOT_FOUND, "Chat not found".to_string()))
    }
}

#[derive(Deserialize)]
pub struct ChatRequest {
    pub input_user: String,
    pub address: String,
}

#[derive(Serialize)]
pub struct ChatResponse {
    pub credits: i64,
    pub response: serde_json::Value,
    pub metadata: Option<serde_json::Value>,
    pub report: String,
}

pub async fn chatbot_interact(
    State(pool): State<PgPool>,
    headers: HeaderMap,
    Json(payload): Json<ChatRequest>,
) -> Result<(StatusCode, Json<ChatResponse>), (StatusCode, String)> {
    // Extract API key from headers
    let api_key = headers
        .get("x-api-key")
        .and_then(|v| v.to_str().ok())
        .ok_or((StatusCode::UNAUTHORIZED, "Missing API key".to_string()))?;

    // Fetch user credit information
    let credit: (i32, String, i64, String) = fetch_credit_info(&pool, api_key).await?;

    // Initialize the SWqueryClient
    let swquery_client = SWqueryClient::new(
        api_key.to_string(),
        "45af5ec2-c5c5-4da2-9226-550f52e126cd".to_string(), // Helius API key
        None,
        Some(Network::Mainnet),
    );

    // Call the query method from the SDK
    let query_result = swquery_client
        .query(&payload.input_user, &payload.address)
        .await
        .map_err(|e| {
            eprintln!("SDK query error: {}", e);
            (StatusCode::INTERNAL_SERVER_ERROR, "Failed to process query".to_string())
        })?;

    // Extract metadata (token information) from the response
    let metadata = query_result.get("metadata").cloned();

    // Generate report based on the query
    let report_input = QueryRequestReport {
        input_user: query_result.clone().to_string(),
        address: payload.address.clone(),
        chatted: payload.input_user.clone(),
    };

    let report = generate_report_service(pool, headers, axum::Json(report_input)).await?;

    // Return the enriched response with metadata
    Ok((
        StatusCode::OK,
        Json(ChatResponse {
            credits: credit.2,
            response: query_result,
            metadata,
            report: report.1.result.clone(),
        }),
    ))
}

=== File: server/src/routes/agent.rs ===

use {
    axum::{
        extract::State,
        http::{HeaderMap, StatusCode},
        Json,
    },
    reqwest::Client,
    serde::{Deserialize, Serialize},
    serde_json::Value,
    sqlx::PgPool,
};

#[derive(Deserialize, Serialize, Debug)]
pub struct QueryRequest {
    #[serde(rename = "inputUser")]
    pub input_user: String,
    pub address: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct QueryRequestReport {
    #[serde(rename = "jsonReturned")]
    pub input_user: String,
    #[serde(rename = "question")]
    pub chatted: String,
    pub address: String,
}

#[derive(Serialize, Deserialize)]
pub struct QueryResponse {
    pub result: QueryResult,
    pub tokens: i64,
}

#[derive(Serialize, Deserialize)]
pub struct QueryResponseReport {
    pub result: String,
    pub tokens: i64,
}

#[derive(Serialize, Deserialize)]
pub struct QueryResult {
    pub response: String,
    status: String,
    params: Value,
}

pub async fn fetch_credit_info(pool: &PgPool, api_key: &str) -> Result<(i32, String, i64, String), (StatusCode, String)> {
    sqlx::query_as::<_, (i32, String, i64, String)>(
        "SELECT c.user_id, u.pubkey, c.balance, c.api_key 
         FROM credits c 
         JOIN users u ON u.id = c.user_id 
         WHERE c.api_key = $1 LIMIT 1",
    )
    .bind(api_key)
    .fetch_optional(pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
    .ok_or((StatusCode::UNAUTHORIZED, "Invalid API key".to_string()))
}

pub async fn send_query_request(payload: &mut QueryRequest) -> Result<QueryResponse, (StatusCode, String)> {
    let client = Client::new();
    payload.input_user = payload.input_user.to_lowercase();
    let response = client
        .post(format!("{}/query/generate-query", crate::AGENT_API_URL))
        .json(payload)
        .send()
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    response
        .json()
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
}

pub async fn send_query_request_report(payload: &mut QueryRequestReport) -> Result<QueryResponseReport, (StatusCode, String)> {
    let client = Client::new();
    payload.input_user = payload.input_user.to_lowercase();
    let response = client
        .post(format!(
            "{}/query/generate-visualization",
            crate::AGENT_API_URL
        ))
        .json(payload)
        .send()
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    response
        .json()
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
}

pub async fn generate_query(
    State(pool): State<PgPool>,
    headers: HeaderMap,
    Json(mut payload): Json<QueryRequest>,
) -> Result<(StatusCode, Json<QueryResponse>), (StatusCode, String)> {
    let api_key = headers
        .get("x-api-key")
        .and_then(|v| v.to_str().ok())
        .ok_or((StatusCode::UNAUTHORIZED, "Missing API key".to_string()))?;

    println!("Getting user info");
    let credit = fetch_credit_info(&pool, api_key).await?;

    let query_response = send_query_request(&mut payload).await?;

    if credit.2 < query_response.tokens {
        return Err((
            StatusCode::PAYMENT_REQUIRED,
            "Insufficient credits".to_string(),
        ));
    }

    sqlx::query("UPDATE credits SET balance = balance - $1 WHERE user_id = $2")
        .bind(query_response.tokens)
        .bind(credit.0)
        .execute(&pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    println!("Summary:
    User ID: {}
    Public Key: {}
    Balance: {}
    API Key: {}
    API response: {}
    Tokens used: {}",
    credit.0, credit.1, credit.2, credit.3, query_response.result.response, query_response.tokens);


    Ok((StatusCode::OK, Json(query_response)))
}

pub async fn generate_report(
    State(pool): State<PgPool>,
    headers: HeaderMap,
    Json(mut payload): Json<QueryRequestReport>,
) -> Result<(StatusCode, Json<QueryResponseReport>), (StatusCode, String)> {
    let api_key = headers
        .get("x-api-key")
        .and_then(|v| v.to_str().ok())
        .ok_or((StatusCode::UNAUTHORIZED, "Missing API key".to_string()))?;

    println!("Getting user info");
    let credit = fetch_credit_info(&pool, api_key).await?;

    let query_response = send_query_request_report(&mut payload).await?;

    if credit.2 < query_response.tokens {
        return Err((
            StatusCode::PAYMENT_REQUIRED,
            "Insufficient credits".to_string(),
        ));
    }

    sqlx::query("UPDATE credits SET balance = balance - $1 WHERE user_id = $2")
        .bind(query_response.tokens)
        .bind(credit.0)
        .execute(&pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    Ok((StatusCode::OK, Json(query_response)))
}

pub async fn generate_report_service(
    pool: PgPool,
    headers: HeaderMap,
    Json(mut payload): Json<QueryRequestReport>,
) -> Result<(StatusCode, Json<QueryResponseReport>), (StatusCode, String)> {
let api_key = headers
        .get("x-api-key")
        .and_then(|v| v.to_str().ok())
        .ok_or((StatusCode::UNAUTHORIZED, "Missing API key".to_string()))?;

    println!("Getting user info");
    let credit = fetch_credit_info(&pool, api_key).await?;

    let query_response = send_query_request_report(&mut payload).await?;

    if credit.2 < query_response.tokens {
        return Err((
            StatusCode::PAYMENT_REQUIRED,
            "Insufficient credits".to_string(),
        ));
    }

    sqlx::query("UPDATE credits SET balance = balance - $1 WHERE user_id = $2")
        .bind(query_response.tokens)
        .bind(credit.0)
        .execute(&pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    Ok((StatusCode::OK, Json(query_response)))
}